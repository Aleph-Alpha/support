{{- if and (hasKey .Values "pgbouncerTemporal") (.Values.pgbouncerTemporal.enabled) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "qs-pgbouncer.fullname" . }}-userlist-pharia
  labels:
    {{- include "qs-pgbouncer.labels" . | nindent 4 }}
    app.kubernetes.io/component: create-secrets-userlist
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "qs-pgbouncer.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: create-secrets-userlist
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "qs-pgbouncer.fullname" . }}
      containers:
        - name: create-pgbouncer-secrets
          image: bitnamilegacy/kubectl:latest
          command: ["/bin/bash"]
          args:
            - -c
            - |
              #!/bin/bash
              set -e

              # Set locale to avoid tr: Illegal byte sequence errors
              export LC_ALL=C
              export LANG=C

              # Colors for output
              RED='\033[0;31m'
              GREEN='\033[0;32m'
              YELLOW='\033[1;33m'
              BLUE='\033[0;34m'
              NC='\033[0m' # No Color

              # Function to print colored output
              print_status() {
                  echo -e "${BLUE}[INFO]${NC} $1"
              }

              print_success() {
                  echo -e "${GREEN}[SUCCESS]${NC} $1"
              }

              print_warning() {
                  echo -e "${YELLOW}[WARNING]${NC} $1"
              }

              print_error() {
                  echo -e "${RED}[ERROR]${NC} $1"
              }

              # Function to create PGbouncer secrets
              create_pgbouncer_userlist_secret() {
                  print_status "Creating PgBouncer userlist secret..."
                  local secret_name="{{ .Values.pgbouncerTemporal.config.existingUserlistSecret }}"
                  local userlist_content=""
                  local pgbouncer_username=""
                  local pgbouncer_password=""

                  print_status "Looking for secrets with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal..."

                  # Get all secrets with both labels
                  local pg_secrets=$(kubectl get secrets -l "app.kubernetes.io/name=qs-postgresql-cluster,qs-postgresql-cluster/name=cluster-temporal" -o name)

                  if [ -z "$pg_secrets" ]; then
                      print_warning "No secrets found with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal"
                      return 1
                  fi

                  # Iterate over each secret and extract user and password
                  for secret in $pg_secrets; do
                      local secret_name_only=$(echo "$secret" | sed 's/secret\///')
                      print_status "Processing secret: $secret_name_only"

                      # Get username from the secret
                      local username=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.username}' | base64 -d 2>/dev/null)
                      if [ -z "$username" ]; then
                          # Try 'user' field as fallback
                          username=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.user}' | base64 -d 2>/dev/null)
                      fi

                      # Get password from the secret
                      local password=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.password}' | base64 -d 2>/dev/null)

                      if [ -z "$username" ]; then
                          print_error "Failed to retrieve username from secret: $secret_name_only"
                          continue
                      fi

                      if [ -z "$password" ]; then
                          print_error "Failed to retrieve password from secret: $secret_name_only"
                          continue
                      fi

                      print_success "Found credentials for user: $username from secret: $secret_name_only"

                      # Check if this is the pgbouncer user and save credentials
                      if [ "$username" = "pgbouncer" ]; then
                          print_status "Found pgbouncer user credentials - saving for admin secret"
                          pgbouncer_username="$username"
                          pgbouncer_password="$password"
                      fi

                      # Add user entry to userlist content
                      userlist_content+="\"$username\" \"$password\"\n"
                  done

                  if [ -z "$userlist_content" ]; then
                      print_error "No valid user credentials found in any secrets with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal"
                      return 1
                  fi

                  # Remove trailing newline
                  userlist_content=$(echo -e "$userlist_content" | sed '$d')

                  print_status "Creating PgBouncer userlist secret: $secret_name"

                  # Create the secret with userlist.txt key
                  kubectl create secret generic "$secret_name" \
                      --from-literal=userlist.txt="$userlist_content" \
                      --dry-run=client -o yaml | \
                      kubectl label --local -f - \
                      app.kubernetes.io/name="{{ include "qs-pgbouncer.fullname" . }}" \
                      -o yaml | kubectl apply -f -

                  print_success "Created PgBouncer userlist secret: $secret_name"

                  # Export pgbouncer credentials for admin secret creation
                  export PGBOUNCER_FOUND_USERNAME="$pgbouncer_username"
                  export PGBOUNCER_FOUND_PASSWORD="$pgbouncer_password"
              }

              # Function to create admin secret with distinct keys adminUser/adminPassword
              create_admin_secret() {
                  local admin_secret_name="{{ .Values.pgbouncerTemporal.config.existingAdminSecret }}"
                  local admin_user_key="adminUser"
                  local admin_password_key="adminPassword"

                  # Check if secret already exists
                  if kubectl get secret "$admin_secret_name" >/dev/null 2>&1; then
                      print_status "Admin secret $admin_secret_name already exists; skipping creation"
                      return 0
                  fi

                  # Use found pgbouncer credentials if available, otherwise generate
                  local admin_password_val="$PGBOUNCER_FOUND_PASSWORD"

                  print_status "Creating admin secret $admin_secret_name with user 'pgbouncer'"
                  kubectl create secret generic "$admin_secret_name" \
                      --from-literal=${admin_user_key}="pgbouncer" \
                      --from-literal=${admin_password_key}="$admin_password_val" \
                      --dry-run=client -o yaml | kubectl apply -f -
                  print_success "Created admin secret $admin_secret_name"
              }

              # Main execution
              main() {
                  print_status "Starting secret creation for pharia-ai-helm-chart..."
                  echo ""

                  # Check if kubectl is available
                  if ! command -v kubectl &> /dev/null; then
                      print_error "kubectl is not installed or not in PATH"
                      exit 1
                  fi

                  # Create pgbouncer userlist secret
                  create_pgbouncer_userlist_secret

                  # Create admin secret (if enabled and absent)
                  create_admin_secret
                  echo ""

                  print_success "pgbouncer userlist and admin secrets have been created successfully!"
              }

              # Run main function
              main "$@"
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "100m"
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
{{- end }}
