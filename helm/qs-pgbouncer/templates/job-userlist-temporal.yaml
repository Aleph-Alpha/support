{{- if and (hasKey .Values "pgbouncerTemporal") (.Values.pgbouncerTemporal.enabled) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "qs-pgbouncer.fullname" . }}-userlist-temporal
  labels:
    {{- include "qs-pgbouncer.labels" . | nindent 4 }}
    app.kubernetes.io/component: create-secrets-userlist
  annotations:
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "qs-pgbouncer.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: create-secrets-userlist
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "qs-pgbouncer.fullname" . }}
      containers:
        - name: create-pgbouncer-secrets
          image: bitnamilegacy/kubectl:latest
          command: ["/bin/bash"]
          args:
            - -c
            - |
              #!/bin/bash
              set -e
              
              # Set locale to avoid tr: Illegal byte sequence errors
              export LC_ALL=C
              export LANG=C

              # Colors for output
              RED='\033[0;31m'
              GREEN='\033[0;32m'
              YELLOW='\033[1;33m'
              BLUE='\033[0;34m'
              NC='\033[0m' # No Color

              # Function to print colored output
              print_status() {
                  echo -e "${BLUE}[INFO]${NC} $1"
              }

              print_success() {
                  echo -e "${GREEN}[SUCCESS]${NC} $1"
              }

              print_warning() {
                  echo -e "${YELLOW}[WARNING]${NC} $1"
              }

              print_error() {
                  echo -e "${RED}[ERROR]${NC} $1"
              }

              # Function to create PGbouncer secrets
              create_pgbouncer_userlist_secret() {
                  print_status "Creating PgBouncer userlist secret..."
                  local secret_name="{{ .Values.pgbouncerTemporal.userlist.secret}}"
                  local userlist_content=""
                  
                  print_status "Looking for secrets with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal..."
                  
                  # Get all secrets with both labels
                  local pg_secrets=$(kubectl get secrets -l "app.kubernetes.io/name=qs-postgresql-cluster,qs-postgresql-cluster/name=cluster-temporal" -o name)
                  
                  if [ -z "$pg_secrets" ]; then
                      print_warning "No secrets found with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal"
                      return 1
                  fi
                  
                  # Iterate over each secret and extract user and password
                  for secret in $pg_secrets; do
                      local secret_name_only=$(echo "$secret" | sed 's/secret\///')
                      print_status "Processing secret: $secret_name_only"
                      
                      # Get username from the secret
                      local username=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.username}' | base64 -d 2>/dev/null)
                      if [ -z "$username" ]; then
                          # Try 'user' field as fallback
                          username=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.user}' | base64 -d 2>/dev/null)
                      fi
                      
                      # Get password from the secret
                      local password=$(kubectl get secret "$secret_name_only" -o jsonpath='{.data.password}' | base64 -d 2>/dev/null)
                      
                      if [ -z "$username" ]; then
                          print_error "Failed to retrieve username from secret: $secret_name_only"
                          continue
                      fi
                      
                      if [ -z "$password" ]; then
                          print_error "Failed to retrieve password from secret: $secret_name_only"
                          continue
                      fi
                      
                      print_success "Found credentials for user: $username from secret: $secret_name_only"
                      
                      # Add user entry to userlist content
                      userlist_content+="\"$username\" \"$password\"\n"
                  done
                  
                  if [ -z "$userlist_content" ]; then
                      print_error "No valid user credentials found in any secrets with labels app.kubernetes.io/name=qs-postgresql-cluster and qs-postgresql-cluster/name=cluster-temporal"
                      return 1
                  fi
                  
                  # Remove trailing newline
                  userlist_content=$(echo -e "$userlist_content" | sed '$d')
                  
                  print_status "Creating PgBouncer userlist secret: $secret_name"
                  
                  # Create the secret with userlist.txt key
                  kubectl create secret generic "$secret_name" \
                      --from-literal=userlist.txt="$userlist_content" \
                      --dry-run=client -o yaml | \
                      kubectl label --local -f - \
                      app.kubernetes.io/name="{{ include "qs-pgbouncer.fullname" . }}" \
                      -o yaml | kubectl apply -f -
                  
                  print_success "Created PgBouncer userlist secret: $secret_name"
              }

              # Main execution
              main() {
                  print_status "Starting secret creation for pharia-ai-helm-chart..."
                  echo ""

                  # Check if kubectl is available
                  if ! command -v kubectl &> /dev/null; then
                      print_error "kubectl is not installed or not in PATH"
                      exit 1
                  fi

                  # Check if openssl is available for password generation
                  if ! command -v openssl &> /dev/null; then
                      print_error "openssl is not installed or not in PATH (needed for password generation)"
                      exit 1
                  fi

                  # Create pgbouncer userlist secret
                  create_pgbouncer_userlist_secret
                  echo ""

                  print_success "pgbouncer userlist secret has been created successfully!"
              }

              # Run main function
              main "$@"
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "100m"
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
{{- end }}

