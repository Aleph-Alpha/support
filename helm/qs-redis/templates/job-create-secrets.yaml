{{- /*
Multi-instance Redis secret creation job.
Creates secrets with host, port, username, and password for each enabled Redis instance.
*/ -}}
{{- $root := . -}}
{{- $instanceKeys := list "pharia-assistant-api-redis" "pharia-transcribe-app-redis" -}}
{{- $instances := dict -}}
{{- range $k := $instanceKeys }}
    {{- $cfg := index $root.Values $k | default dict -}}
    {{- if and $cfg $cfg.enabled $cfg.redisStandalone $cfg.redisStandalone.redisSecret }}
        {{- $_ := set $instances $k $cfg -}}
    {{- end -}}
{{- end -}}
{{- if gt (len $instances) 0 }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "qs-redis.fullname" . }}-create-secrets
  labels:
    {{- include "qs-redis.labels" . | nindent 4 }}
    app.kubernetes.io/component: create-redis-secrets
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "qs-redis.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: create-redis-secrets
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "qs-redis.serviceAccountName" . }}
      containers:
        - name: create-redis-secrets
          image: "{{ $root.Values.jobImage.repository }}:{{ $root.Values.jobImage.tag }}"
          imagePullPolicy: {{ $root.Values.jobImage.pullPolicy }}
          command: ["/bin/bash"]
          args:
            - -c
            - |
              #!/bin/bash
              set -e

              # Colors for output
              RED='\033[0;31m'
              GREEN='\033[0;32m'
              YELLOW='\033[1;33m'
              BLUE='\033[0;34m'
              NC='\033[0m'

              print_status() { echo -e "${BLUE}[INFO]${NC} $1"; }
              print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
              print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
              print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

              generate_password() {
                  openssl rand -base64 32 | tr -d "=+/" | cut -c1-25
              }

              print_status "Redis Secret Creation Job"
              print_status "=========================="
              echo ""

              secrets_created=0
              secrets_updated=0
              secrets_skipped=0

              {{- range $name, $cfg := $instances }}
              echo "----"
              print_status "Processing Redis instance: {{ $name }}"

              SECRET_NAME="{{ $cfg.redisStandalone.redisSecret.secretName }}"
              SECRET_KEY="{{ $cfg.redisStandalone.redisSecret.secretKey }}"
              INSTANCE_NAME="{{ $name }}"
              REDIS_HOST="{{ $cfg.redisStandalone.name }}"
              REDIS_PORT="6379"
              REDIS_USERNAME="default"

              print_status "Secret: $SECRET_NAME"
              print_status "Redis Host: $REDIS_HOST"

              if kubectl get secret "$SECRET_NAME" &> /dev/null; then
                  print_status "Secret '$SECRET_NAME' exists, preserving password"
                  EXISTING_PASSWORD=$(kubectl get secret "$SECRET_NAME" -o jsonpath="{.data.$SECRET_KEY}" 2>/dev/null | base64 -d 2>/dev/null || echo "")

                  if [[ -z "$EXISTING_PASSWORD" ]]; then
                      print_warning "Secret exists but password key not found, regenerating"
                      PASSWORD=$(generate_password)
                  else
                      print_status "Using existing password"
                      PASSWORD="$EXISTING_PASSWORD"
                  fi
              else
                  print_status "Creating new secret: $SECRET_NAME"
                  PASSWORD=$(generate_password)
              fi

              kubectl create secret generic "$SECRET_NAME" \
                  --from-literal="host=$REDIS_HOST" \
                  --from-literal="port=$REDIS_PORT" \
                  --from-literal="username=$REDIS_USERNAME" \
                  --from-literal="$SECRET_KEY=$PASSWORD" \
                  --dry-run=client -o yaml | \
                  kubectl label --local -f - \
                      app.kubernetes.io/name="{{ include "qs-redis.name" $root }}" \
                      app.kubernetes.io/instance="{{ $root.Release.Name }}" \
                      app.kubernetes.io/managed-by="{{ $root.Release.Service }}" \
                      qs-redis/instance="$INSTANCE_NAME" \
                      qs-redis/type="redis-secret" \
                      -o yaml | kubectl apply -f -

              if kubectl get secret "$SECRET_NAME" &> /dev/null; then
                  print_success "Secret '$SECRET_NAME' ready for {{ $name }}"
                  if [[ -z "$EXISTING_PASSWORD" ]]; then
                      secrets_created=$((secrets_created + 1))
                  else
                      secrets_updated=$((secrets_updated + 1))
                  fi
              else
                  print_error "Failed to create/update secret '$SECRET_NAME'"
                  exit 1
              fi

              {{- end }}

              echo ""
              print_status "Summary:"
              print_status "  - Created: $secrets_created"
              print_status "  - Updated: $secrets_updated"
              print_status "  - Skipped: $secrets_skipped"
              echo ""
              print_success "All Redis secrets processed successfully!"
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "500m"
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
{{- else }}
# No Redis instances enabled - skipping secret creation job
{{- end }}
