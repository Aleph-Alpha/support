{{- /*
        Multi-instance Redis ACL secret creation job.
        Collect supported instance keys and filter to those enabled with ACL + users.
        NOTE: Use $root to preserve original chart context inside range loops.
*/ -}}
{{- $root := . -}}
{{- $instanceKeys := list "pharia-transcribe-app-redis" "pharia-assistant-api-redis" -}}
{{- $instances := dict -}}
{{- range $k := $instanceKeys }}
    {{- $cfg := index $root.Values $k | default dict -}}
    {{- if and $cfg $cfg.enabled $cfg.auth $cfg.auth.acl $cfg.auth.acl.enabled ($cfg.auth.acl.users) }}
        {{- $_ := set $instances $k $cfg -}}
    {{- end -}}
{{- end -}}
{{- if gt (len $instances) 0 }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "qs-redis.fullname" . }}-create-acl-secrets
  labels:
    {{- include "qs-redis.labels" . | nindent 4 }}
    app.kubernetes.io/component: create-redis-acl-secrets
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      labels:
        {{- include "qs-redis.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: create-redis-acl-secrets
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "qs-redis.serviceAccountName" . }}
      containers:
        - name: create-redis-acl-secrets
          image: bitnamilegacy/kubectl:latest
          command: ["/bin/bash"]
          args:
            - -c
            - |
              #!/bin/bash
              set -e

              # Colors for output
              RED='\033[0;31m'
              GREEN='\033[0;32m'
              YELLOW='\033[1;33m'
              BLUE='\033[0;34m'
              NC='\033[0m' # No Color

              # Function to print colored output
              print_status() {
                  echo -e "${BLUE}[INFO]${NC} $1"
              }

              print_success() {
                  echo -e "${GREEN}[SUCCESS]${NC} $1"
              }

              print_warning() {
                  echo -e "${YELLOW}[WARNING]${NC} $1"
              }

              print_error() {
                  echo -e "${RED}[ERROR]${NC} $1"
              }

              # Function to generate random password
              generate_password() {
                  openssl rand -base64 32 | tr -d "=+/" | cut -c1-25
              }

              # Main execution
              main() {
                  print_status "Starting Redis ACL secret creation for qs-redis chart..."

                                    # Iterate over each configured Redis instance from Helm template
                                    {{- range $name, $cfg := $instances }}
                                    echo "----"
                                    print_status "Instance: {{$name}}"
                                    local secret_name="{{ $cfg.auth.acl.userSecret | default (printf "%s-acl-users-secret" $name) }}"
                                    local acl_users=(
                                    {{- range $cfg.auth.acl.users }}
                                        "{{ .username }}"
                                    {{- end }}
                                    )
                                    print_status "Secret target: $secret_name"
                                    print_status "Users: ${acl_users[*]}"
                                    if [ ${#acl_users[@]} -eq 0 ]; then
                                        print_warning "No ACL users defined for {{$name}} - skipping"
                                        continue
                                    fi

                  # Check if secret already exists
                  if kubectl get secret "$secret_name" &> /dev/null; then
                      print_status "Secret '$secret_name' exists, checking for changes..."

                      local needs_update=false
                      local secret_data=""

                      # Check each user
                      for user in "${acl_users[@]}"; do
                          local existing_password=$(kubectl get secret "$secret_name" -o jsonpath="{.data.$user}" 2>/dev/null | base64 -d 2>/dev/null || echo "")

                          if [[ -z "$existing_password" ]]; then
                              print_warning "User '$user' not found in existing secret, will add"
                              needs_update=true
                              local password=$(generate_password)
                          else
                              print_status "User '$user' exists, preserving password"
                              local password="$existing_password"
                          fi

                          secret_data="$secret_data --from-literal=$user=$password"
                      done

                      # Check if current secret has extra users not in our list
                      local existing_keys=$(kubectl get secret "$secret_name" -o jsonpath='{.data}' | jq -r 'keys[]' 2>/dev/null || echo "")
                      for existing_key in $existing_keys; do
                          local found=false
                          for user in "${acl_users[@]}"; do
                              if [[ "$existing_key" == "$user" ]]; then
                                  found=true
                                  break
                              fi
                          done
                          if [[ "$found" == "false" ]]; then
                              print_warning "Extra user '$existing_key' found in secret, will be removed"
                              needs_update=true
                          fi
                      done

                      if [[ "$needs_update" == "false" ]]; then
                          print_success "Secret '$secret_name' is up to date, skipping"
                          # proceed to next instance
                          continue
                      fi
                  else
                      print_status "Creating new secret: $secret_name"
                      local secret_data=""

                      # Generate passwords for all users
                      for user in "${acl_users[@]}"; do
                          local password=$(generate_password)
                          secret_data="$secret_data --from-literal=$user=$password"
                          print_status "Generated password for user: $user"
                      done
                  fi

                  # Create or update the secret with proper labels
                  eval "kubectl create secret generic \"$secret_name\" $secret_data --dry-run=client -o yaml" | \
                      kubectl label --local -f - \
                      app.kubernetes.io/name="{{ include "qs-redis.name" $root }}" \
                      app.kubernetes.io/instance="{{ $root.Release.Name }}" \
                      app.kubernetes.io/managed-by="{{ $root.Release.Service }}" \
                      qs-redis/name="{{$name}}" \
                      qs-redis/type="acl-users-secret" \
                      -o yaml | kubectl apply -f -

                  if kubectl get secret "$secret_name" &> /dev/null; then
                      print_success "Secret '$secret_name' ready with users: ${acl_users[*]}"

                      # Display user credentials for verification (optional - remove in production)
                      print_status "User credentials created:"
                      for user in "${acl_users[@]}"; do
                          local user_password=$(kubectl get secret "$secret_name" -o jsonpath="{.data.$user}" | base64 -d)
                          echo "  - $user: xxxxxxx"
                      done
                  else
                      print_error "Failed to create/update secret '$secret_name'"
                      # do not abort whole job; continue to next instance
                      continue
                  fi

                  {{- end }} # end range instances
                  print_success "All Redis ACL secrets for configured instances processed."
              }

              # Check if kubectl is available
              if ! command -v kubectl &> /dev/null; then
                  echo -e "${RED}[ERROR]${NC} kubectl is not installed or not in PATH"
                  exit 1
              fi

              # Check if openssl is available for password generation
              if ! command -v openssl &> /dev/null; then
                  echo -e "${RED}[ERROR]${NC} openssl is not installed or not in PATH (needed for password generation)"
                  exit 1
              fi

              # Check if jq is available for JSON parsing
              if ! command -v jq &> /dev/null; then
                  echo -e "${YELLOW}[WARNING]${NC} jq is not installed - some features may be limited"
              fi

              # Run main function
              main "$@"
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "500m"
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
{{- else }}
# Redis ACL users / configuration not fully enabled - skipping job creation
{{- end }}
