fullnameOverride: "qs-postgresql-cluster"
# ServiceAccount configuration for the secret creation job
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# RBAC configuration for the secret creation job
rbac:
  # Specifies whether a role should be created
  # If false, an existing role with the name specified in roleName will be used
  create: true
  # The name of the role to use or create
  # If not set and create is true, a name is generated using the fullname template
  # If not set and create is false, defaults to "<fullname>-secret-creator"
  roleName: ""

# Image configuration for secret creation jobs
jobImage:
  # -- Container image for kubectl in secret creation jobs
  repository: bitnamilegacy/kubectl
  # -- Image tag for kubectl (set to specific version for stability)
  tag: "1.33.4"
  # -- Image pull policy
  pullPolicy: IfNotPresent

# Configuration for secret creation jobs
jobConfig:
  # -- Log level for secret creation jobs (debug, info, warning, error)
  logLevel: info
  # -- Enable colored output in logs
  coloredOutput: true
  # -- Dry-run mode - if true, shows what would be done without making changes
  dryRun: false
  # -- Fail on error - if false, job continues even if some secrets fail
  failOnError: true

# Configuration for secret cleanup on uninstall
secretCleanup:
  # -- Retain secrets on helm uninstall (true = keep secrets, false = delete secrets)
  retainOnDelete: true

# Configuration for Helm tests
tests:
  # -- PostgreSQL image to use for connection tests (alpine variant is ~40% smaller)
  image: postgres:17-alpine
  # -- SSL mode for PostgreSQL connections (disable, allow, prefer, require, verify-ca, verify-full)
  sslMode: prefer

# PG Cluster for Pharia Applications
clusterPharia:
  enabled: true
  fullnameOverride: qs-postgresql-cluster-pharia
  type: postgresql
  version:
    # -- PostgreSQL major version to use
    postgresql: "17"
  cluster:
    # -- Number of instances
    instances: 3
    # -- Name of the container image, supporting both tags (<image>:<tag>) and digests for deterministic and repeatable deployments:
    # <image>:<tag>@sha256:<digestValue>
    imageName: ""  # Default value depends on type (postgresql/postgis/timescaledb)
    storage:
      size: 250Gi
      storageClass: ""
    postgresql:
      parameters:
        max_connections: "500"
        shared_buffers: "6GB"
        effective_cache_size: "10GB"
        checkpoint_completion_target: "0.9"
        wal_buffers: "64MB"
        default_statistics_target: "100"
        maintenance_work_mem: "1GB"
        work_mem: "16MB"
        effective_io_concurrency: "200"
        max_worker_processes: "4"
        max_parallel_workers_per_gather: "2"
        max_parallel_workers: "4"
        max_wal_size: "2GB"
        min_wal_size: "1GB"
    resources:
      requests:
        memory: "24Gi"
        cpu: "4"
      limits:
        memory: "24Gi"
        cpu: "8"
    roles:
      - name: "document_index"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (document_index)
        passwordSecret:
          name: "qs-postgresql-cluster-access-document-index"
        login: true
        superuser: false
        replication: false
      - name: "pharia_os"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_os)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-os"
        login: true
        superuser: false
        replication: false
      - name: "inference_api"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (inference_api)
        passwordSecret:
          name: "qs-postgresql-cluster-access-inference-api"
        login: true
        superuser: false
        replication: false
      - name: "pharia_studio"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_studio)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-studio"
        login: true
        superuser: false
        replication: false
      - name: "pharia_oauth_gateway"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_oauth_gateway)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-oauth-gateway"
        login: true
        superuser: false
        replication: false
      - name: "pharia_assistant"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_assistant)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-assistant"
        login: true
        superuser: false
        replication: false
      - name: "pharia_chat"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_chat)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-chat"
        login: true
        superuser: false
        replication: false
      - name: "pharia_catch"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_catch)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-catch"
        login: true
        superuser: false
        replication: false
      - name: "zitadel"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (zitadel)
        passwordSecret:
          name: "qs-postgresql-cluster-access-zitadel"
        login: true
        superuser: false
        replication: false
      - name: "openfga"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (openfga)
        passwordSecret:
          name: "qs-postgresql-cluster-access-openfga"
        login: true
        superuser: false
        replication: false
      - name: "dex"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (dex)
        passwordSecret:
          name: "qs-postgresql-cluster-access-dex"
        login: true
        superuser: false
        replication: false
      - name: "pharia_conductor"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_conductor)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-conductor"
        login: true
        superuser: false
        replication: false
      - name: "pharia_numinous"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_numinous)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-numinous"
        login: true
        superuser: false
        replication: false
      - name: "pharia_transcribe_app"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_transcribe_app)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-transcribe-app"
        login: true
        superuser: false
        replication: false
      - name: "pharia_data"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_data)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-data"
        login: true
        superuser: false
        replication: false
      - name: "mlflow"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (mlflow)
        passwordSecret:
          name: "qs-postgresql-cluster-access-mlflow"
        login: true
        superuser: false
        replication: false
  backups:
    # -- You need to configure backups manually, so backups are disabled by default.
    enabled: false
  # -- Configuration for role-to-pooler mappings
  config:
    # Default pooler for roles without specific mapping
    # If empty or not set, unmapped roles use direct cluster connection
    # If set, unmapped roles will use this pooler
    defaultPooler: "transaction"  # All Pharia roles use transaction pooler by default
    
    # Role-specific pooler mappings (overrides defaultPooler)
    # Maps each role to a specific pooler (optional)
    # Empty means all roles use the default pooler above
    rolePoolerMappings: {}
      # Examples of role-specific overrides:
      
      # Override to use direct connection (bypass pooler)
      # Useful for: admin users, long-running jobs, debugging
      # admin_user: ""
      
      # Override to use a different pooler (if you have multiple)
      # pharia_os: "session"  # Would need session pooler defined
      
      # Real-world example: Admin needs direct access for maintenance
      # pharia_admin: ""
      
      # Real-world example: Background jobs that hold long transactions
      # background_worker: ""
      
      # Note: Most applications should use the default pooler
      # Only override when you have specific requirements
  # -- List of PgBouncer poolers
  poolers:
    # Transaction mode pooler - for databases that work well with transaction pooling
    # Recommended for: document-index, and other databases without prepared statements
    - name: transaction
      # -- PgBouncer type of service to forward traffic to.
      type: rw
      # -- PgBouncer pooling mode
      poolMode: transaction
      # -- Number of PgBouncer instances
      instances: 1
      # -- PgBouncer configuration parameters
      parameters:
        max_client_conn: "1000"
        default_pool_size: "30"
        max_prepared_statements: "100"
        server_tls_sslmode: require
        ignore_startup_parameters: extra_float_digits, jit
        auth_type: scram-sha-256
        log_connections: "0"
        log_disconnections: "0"
        log_pooler_errors: "1"
        log_stats: "1"

# PG Cluster for Temporal
clusterTemporal:
  enabled: true
  fullnameOverride: qs-postgresql-cluster-temporal
  type: postgresql
  version:
    # -- PostgreSQL major version to use
    postgresql: "17"
  cluster:
    # -- Number of instances
    instances: 3
    # -- Name of the container image, supporting both tags (<image>:<tag>) and digests for deterministic and repeatable deployments:
    # <image>:<tag>@sha256:<digestValue>
    imageName: ""  # Default value depends on type (postgresql/postgis/timescaledb)
    storage:
      size: 250Gi
      storageClass: ""
    postgresql:
      parameters:
        max_connections: "200"
        shared_buffers: "6GB"
        effective_cache_size: "10GB"
        checkpoint_completion_target: "0.9"
        wal_buffers: "64MB"
        default_statistics_target: "100"
        maintenance_work_mem: "1GB"
        work_mem: "32MB"
        effective_io_concurrency: "200"
        max_worker_processes: "4"
        max_parallel_workers_per_gather: "2"
        max_parallel_workers: "4"
        max_wal_size: "2GB"
        min_wal_size: "1GB"
    resources:
      requests:
        memory: "16Gi"
        cpu: "4"
      limits:
        memory: "16Gi"
        cpu: "8"
    roles:
      - name: "temporal"
        connectionLimit: -1
        ensure: present
        inherit: true
        # password and username key should exist in secret. username key should be the same as the name of the user
        passwordSecret:
          name: "qs-postgresql-cluster-access-temporal"
        login: true
        createdb: true
        superuser: false
        replication: false
      - name: "temporal_visibility"
        connectionLimit: -1
        ensure: present
        inherit: true
        # password and username key should exist in secret. username key should be the same as the name of the user
        passwordSecret:
          name: "qs-postgresql-cluster-access-temporal-visibility"
        login: true
        createdb: true
        superuser: false
        replication: false
  backups:
    # -- You need to configure backups manually, so backups are disabled by default.
    enabled: false
  # -- Configuration for role-to-pooler mappings
  config:
    # Default pooler for roles without specific mapping
    # If empty or not set, unmapped roles use direct cluster connection
    # If set, unmapped roles will use this pooler
    defaultPooler: "session"  # All temporal roles use session pooler by default
    
    # Role-specific pooler mappings (overrides defaultPooler)
    # Maps each role to a specific pooler (optional)
    rolePoolerMappings:
      # temporal: session  # Not needed - uses defaultPooler
      # temporal_visibility: session  # Not needed - uses defaultPooler
      # Add role-specific overrides here if needed
  # -- List of PgBouncer poolers
  poolers:
    # Session mode pooler - for databases that require session state
    # Recommended for: Temporal workflow databases requiring session state
    - name: session
      # -- PgBouncer type of service to forward traffic to.
      type: rw
      # -- PgBouncer pooling mode
      poolMode: session
      # -- Number of PgBouncer instances
      instances: 1
      # -- PgBouncer configuration parameters
      parameters:
        max_client_conn: "600"
        default_pool_size: "80"
        reserve_pool_size: "10"
        server_lifetime: "3600"
        server_idle_timeout: "600"
        server_tls_sslmode: require
        ignore_startup_parameters: extra_float_digits
        auth_type: scram-sha-256
        log_connections: "0"
        log_disconnections: "0"
        log_pooler_errors: "1"
        log_stats: "1"
