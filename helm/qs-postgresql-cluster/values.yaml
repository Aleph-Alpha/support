fullnameOverride: "qs-postgresql-cluster"
# ServiceAccount configuration for the secret creation job
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# RBAC configuration for the secret creation job
rbac:
  # Specifies whether a role should be created
  # If false, an existing role with the name specified in roleName will be used
  create: true
  # The name of the role to use or create
  # If not set and create is true, a name is generated using the fullname template
  # If not set and create is false, defaults to "<fullname>-secret-creator"
  roleName: ""

# Image configuration for secret creation jobs
jobImage:
  # -- Container image for kubectl in secret creation jobs
  repository: bitnamilegacy/kubectl
  # -- Image tag for kubectl (set to specific version for stability)
  tag: "1.33.4"
  # -- Image pull policy
  pullPolicy: IfNotPresent

# Configuration for secret creation jobs
jobConfig:
  # -- Log level for secret creation jobs (debug, info, warning, error)
  logLevel: info
  # -- Enable colored output in logs
  coloredOutput: true
  # -- Dry-run mode - if true, shows what would be done without making changes
  dryRun: false
  # -- Fail on error - if false, job continues even if some secrets fail
  failOnError: true

# Configuration for secret generation job
secretGenerationJob:
  # -- Enable secret generation job (true = run job, false = skip job)
  enabled: true

# Configuration for secret cleanup on uninstall
secretCleanup:
  # -- Retain secrets on helm uninstall (true = keep secrets, false = delete secrets)
  retainOnDelete: true

# Configuration for Helm tests
tests:
  # -- PostgreSQL image to use for connection tests (alpine variant is ~40% smaller)
  image: postgres:17-alpine
  # -- SSL mode for PostgreSQL connections (disable, allow, prefer, require, verify-ca, verify-full)
  sslMode: prefer

# PG Cluster for Pharia Applications
clusterPharia:
  enabled: true
  # -- Cluster mode of operation. Available modes:
  # * `standalone` - default mode. Creates new or updates an existing CNPG cluster.
  # * `replica` - Creates a replica cluster from an existing CNPG cluster. # TODO
  # * `recovery` - Same as standalone but creates a cluster from a backup, object store or via pg_basebackup.
  mode: standalone
  fullnameOverride: qs-postgresql-cluster-pharia
  type: postgresql
  version:
    # -- PostgreSQL major version to use
    postgresql: "17"
  cluster:
    # -- Number of instances
    instances: 3
    # -- Name of the container image, supporting both tags (<image>:<tag>) and digests for deterministic and repeatable deployments:
    # <image>:<tag>@sha256:<digestValue>
    imageName: ""  # Default value depends on type (postgresql/postgis/timescaledb)
    storage:
      size: 250Gi
      storageClass: ""
    postgresql:
      parameters:
        max_connections: "500"
        shared_buffers: "6GB"
        effective_cache_size: "10GB"
        checkpoint_completion_target: "0.9"
        wal_buffers: "64MB"
        default_statistics_target: "100"
        maintenance_work_mem: "1GB"
        work_mem: "16MB"
        effective_io_concurrency: "200"
        max_worker_processes: "4"
        max_parallel_workers_per_gather: "2"
        max_parallel_workers: "4"
        max_wal_size: "2GB"
        min_wal_size: "1GB"
    resources:
      requests:
        memory: "24Gi"
        cpu: "4"
      limits:
        memory: "24Gi"
        cpu: "8"
    roles:
      - name: "document_index"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (document_index)
        passwordSecret:
          name: "qs-postgresql-cluster-access-document-index"
        login: true
        superuser: false
        replication: false
      - name: "pharia_os"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_os)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-os"
        login: true
        superuser: false
        replication: false
      - name: "inference_api"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (inference_api)
        passwordSecret:
          name: "qs-postgresql-cluster-access-inference-api"
        login: true
        superuser: false
        replication: false
      - name: "pharia_studio"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_studio)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-studio"
        login: true
        superuser: false
        replication: false
      - name: "pharia_oauth_gateway"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_oauth_gateway)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-oauth-gateway"
        login: true
        superuser: false
        replication: false
      - name: "pharia_assistant"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_assistant)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-assistant"
        login: true
        superuser: false
        replication: false
      - name: "pharia_chat"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_chat)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-chat"
        login: true
        superuser: false
        replication: false
      - name: "pharia_catch"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the same as the name of the user (pharia_catch)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-catch"
        login: true
        superuser: false
        replication: false
      - name: "zitadel"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (zitadel)
        passwordSecret:
          name: "qs-postgresql-cluster-access-zitadel"
        login: true
        superuser: false
        replication: false
      - name: "openfga"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (openfga)
        passwordSecret:
          name: "qs-postgresql-cluster-access-openfga"
        login: true
        superuser: false
        replication: false
      - name: "dex"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (dex)
        passwordSecret:
          name: "qs-postgresql-cluster-access-dex"
        login: true
        superuser: false
        replication: false
      - name: "pharia_conductor"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_conductor)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-conductor"
        login: true
        superuser: false
        replication: false
      - name: "pharia_numinous"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_numinous)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-numinous"
        login: true
        superuser: false
        replication: false
      - name: "pharia_transcribe_app"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_transcribe_app)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-transcribe-app"
        login: true
        superuser: false
        replication: false
      - name: "pharia_data"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (pharia_data)
        passwordSecret:
          name: "qs-postgresql-cluster-access-pharia-data"
        login: true
        superuser: false
        replication: false
      - name: "mlflow"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (mlflow)
        passwordSecret:
          name: "qs-postgresql-cluster-access-mlflow"
        login: true
        superuser: false
        replication: false
      - name: "creance"
        connectionLimit: -1
        ensure: present
        inherit: true
        # `password` and `username` key should exist in secret. username key should be the name of the user (mlflow)
        passwordSecret:
          name: "qs-postgresql-cluster-access-creance"
        login: true
        superuser: false
        replication: false
  backups:
    # -- You need to configure backups manually, so backups are disabled by default.
    # For detailed configuration options, see: https://github.com/cloudnative-pg/charts/tree/main/charts/cluster
    enabled: false
    # -- Preferred backup target: prefer-standby to avoid impacting primary
    target: prefer-standby
    # -- Overrides the provider specific default endpoint. Defaults to: https://s3.<region>.amazonaws.com
    endpointURL: ""  # Leave empty if using the default S3 endpoint
    # -- Specifies a CA bundle to validate a privately signed certificate.
    endpointCA:
      # -- Creates a secret with the given value if true, otherwise uses an existing secret.
      create: false
      name: ""
      key: ""
      value: ""
    # -- Overrides the provider specific default path. Format: s3://<bucket><path>
    # Recommended naming: Use timestamp/version to enable same-name cluster recovery
    # Examples:
    #   - s3://my-backups/postgresql-prod-2025-11-17/
    #   - s3://my-backups/pharia-cluster-2025-11/
    #   - s3://my-backups/prod-YYYY-MM-DD/
    # When recovering, use a NEW timestamp (e.g., 2025-11-18) for post-recovery backups
    # This allows recovery to read from old path while writing new backups to a fresh timestamped path
    destinationPath: ""
    # -- Provider type (only S3-compatible storage is configured)
    provider: s3
    s3:
      region: ""
      bucket: ""
      path: "/"
      accessKey: ""
      secretKey: ""
      # -- Use the role based authentication without providing explicitly the keys
      inheritFromIAMRole: false
    secret:
      # -- Whether to create a secret for the backup credentials
      create: true
      # -- Name of the backup credentials secret
      name: ""
    wal:
      # -- WAL compression method. One of `` (for no compression), `gzip`, `bzip2` or `snappy`.
      compression: gzip
      # -- Whether to instruct the storage provider to encrypt WAL files. One of `` (use the storage container default), `AES256` or `aws:kms`.
      encryption: ""
      # -- Number of WAL files to be archived or restored in parallel.
      maxParallel: 8
    data:
      # -- Data compression method. One of `` (for no compression), `gzip`, `bzip2` or `snappy`.
      compression: gzip
      # -- Whether to instruct the storage provider to encrypt data files. One of `` (use the storage container default), `AES256` or `aws:kms`.
      encryption: ""
      # -- Number of data files to be archived or restored in parallel.
      jobs: 2
    scheduledBackups:
      - name: daily-backup
        # -- Schedule in cron format
        schedule: "0 0 0 * * *"
        # -- Backup owner reference
        backupOwnerReference: self
        # -- Backup method, can be `barmanObjectStore` (default) or `volumeSnapshot`
        method: barmanObjectStore
    # -- Retention policy for backups
    retentionPolicy: "30d"
  recovery:
    # -- For detailed configuration options, see: https://github.com/cloudnative-pg/charts/tree/main/charts/cluster
    ##
    # -- Available recovery methods:
    # * `backup` - Recovers a CNPG cluster from a CNPG backup (PITR supported) Needs to be on the same cluster in the same namespace.
    # * `object_store` - Recovers a CNPG cluster from a barman object store (PITR supported).
    # * `pg_basebackup` - Recovers a CNPG cluster viaa streaming replication protocol. Useful if you want to
    #        migrate databases to CloudNativePG, even from outside Kubernetes.
    # * `import` - Import one or more databases from an existing Postgres cluster.
    method: object_store

    ## -- Point in time recovery target. Specify one of the following:
    pitrTarget:
      # -- Time in RFC3339 format
      time: ""
    
    ## -- Recovery target settings for controlling recovery behavior
    # Options: pause, promote, shutdown
    # 'promote' is recommended - promotes to read-write immediately after recovery
    recoveryTarget: "promote"

    ##
    # -- Backup Recovery Method
    backupName: ""  # Name of the backup to recover from. Required if method is `backup`.

    ##
    # -- The original cluster name when used in backups. Also known as serverName.
    clusterName: "qs-postgresql-cluster-pharia"
    # -- Name of the database used by the application. Default: `app`.
    database: app
    # -- Name of the owner of the database in the instance to be used by applications. Defaults to the value of the `database` key.
    owner: ""
    # -- Overrides the provider specific default endpoint. Defaults to: https://s3.<region>.amazonaws.com
    # Leave empty if using the default S3 endpoint
    endpointURL: ""
    # -- Specifies a CA bundle to validate a privately signed certificate.
    endpointCA:
      # -- Creates a secret with the given value if true, otherwise uses an existing secret.
      create: false
      name: ""
      key: ""
      value: ""
    # -- Overrides the provider specific default path. Format: s3://<bucket><path>
    # IMPORTANT: For disaster recovery with same cluster name:
    #   - Set this to READ from the production backup path (e.g., s3://my-backups/prod-2025-11-17/)
    #   - Set backups.destinationPath to WRITE to a NEW timestamped path (e.g., s3://my-backups/prod-2025-11-18/)
    # This prevents "Expected empty archive" errors during recovery while maintaining same cluster name
    # Example recovery scenario:
    #   1. Production backups: s3://my-backups/postgresql-prod-2025-11-17/ (original)
    #   2. Disaster occurs on 2025-11-18, cluster deleted
    #   3. Recovery reads FROM: s3://my-backups/postgresql-prod-2025-11-17/ (this field)
    #   4. New backups write TO: s3://my-backups/postgresql-prod-2025-11-18/ (backups.destinationPath)
    # Benefits: Clear timeline, allows multiple recoveries, consistent naming pattern
    destinationPath: ""
    # -- Provider type (only S3-compatible storage is configured)
    provider: s3
    s3:
      region: ""
      bucket: ""
      path: "/"
      accessKey: ""
      secretKey: ""
      # -- Use the role based authentication without providing explicitly the keys
      inheritFromIAMRole: false
    secret:
      # -- Whether to create a secret for the backup credentials
      create: true
      # -- Name of the backup credentials secret
      name: ""


  # -- Configuration for role-to-pooler mappings
  config:
    # Default pooler for roles without specific mapping
    # If empty or not set, unmapped roles use direct cluster connection
    # If set, unmapped roles will use this pooler
    defaultPooler: "transaction"  # All Pharia roles use transaction pooler by default

    # Role-specific pooler mappings (overrides defaultPooler)
    # Maps each role to a specific pooler (optional)
    # Empty means all roles use the default pooler above
    rolePoolerMappings: {}
      # Examples of role-specific overrides:

      # Override to use direct connection (bypass pooler)
      # Useful for: admin users, long-running jobs, debugging
      # admin_user: ""

      # Override to use a different pooler (if you have multiple)
      # pharia_os: "session"  # Would need session pooler defined

      # Real-world example: Admin needs direct access for maintenance
      # pharia_admin: ""

      # Real-world example: Background jobs that hold long transactions
      # background_worker: ""

      # Note: Most applications should use the default pooler
      # Only override when you have specific requirements
  # -- List of PgBouncer poolers
  poolers:
    # Transaction mode pooler - for databases that work well with transaction pooling
    # Recommended for: document-index, and other databases without prepared statements
    - name: transaction
      # -- PgBouncer type of service to forward traffic to.
      type: rw
      # -- PgBouncer pooling mode
      poolMode: transaction
      # -- Number of PgBouncer instances
      instances: 3
      # -- PgBouncer configuration parameters
      parameters:
        max_client_conn: "1000"
        default_pool_size: "30"
        max_prepared_statements: "100"
        server_tls_sslmode: require
        ignore_startup_parameters: extra_float_digits, jit
        auth_type: scram-sha-256
        log_connections: "0"
        log_disconnections: "0"
        log_pooler_errors: "1"
        log_stats: "1"

# PG Cluster for Temporal
clusterTemporal:
  enabled: true
  fullnameOverride: qs-postgresql-cluster-temporal
  type: postgresql
  version:
    # -- PostgreSQL major version to use
    postgresql: "17"
  cluster:
    # -- Number of instances
    instances: 3
    # -- Name of the container image, supporting both tags (<image>:<tag>) and digests for deterministic and repeatable deployments:
    # <image>:<tag>@sha256:<digestValue>
    imageName: ""  # Default value depends on type (postgresql/postgis/timescaledb)
    storage:
      size: 250Gi
      storageClass: ""
    postgresql:
      parameters:
        max_connections: "200"
        shared_buffers: "6GB"
        effective_cache_size: "10GB"
        checkpoint_completion_target: "0.9"
        wal_buffers: "64MB"
        default_statistics_target: "100"
        maintenance_work_mem: "1GB"
        work_mem: "32MB"
        effective_io_concurrency: "200"
        max_worker_processes: "4"
        max_parallel_workers_per_gather: "2"
        max_parallel_workers: "4"
        max_wal_size: "2GB"
        min_wal_size: "1GB"
    resources:
      requests:
        memory: "16Gi"
        cpu: "4"
      limits:
        memory: "16Gi"
        cpu: "8"
    roles:
      - name: "temporal"
        connectionLimit: -1
        ensure: present
        inherit: true
        # password and username key should exist in secret. username key should be the same as the name of the user
        passwordSecret:
          name: "qs-postgresql-cluster-access-temporal"
        login: true
        createdb: true
        superuser: false
        replication: false
      - name: "temporal_visibility"
        connectionLimit: -1
        ensure: present
        inherit: true
        # password and username key should exist in secret. username key should be the same as the name of the user
        passwordSecret:
          name: "qs-postgresql-cluster-access-temporal-visibility"
        login: true
        createdb: true
        superuser: false
        replication: false
  backups:
    # -- You need to configure backups manually, so backups are disabled by default.
    # For detailed configuration options, see: https://github.com/cloudnative-pg/charts/tree/main/charts/cluster
    enabled: false
    # -- Preferred backup target: prefer-standby to avoid impacting primary
    target: prefer-standby
    # -- Overrides the provider specific default endpoint. Defaults to: https://s3.<region>.amazonaws.com
    endpointURL: ""  # Leave empty if using the default S3 endpoint
    # -- Specifies a CA bundle to validate a privately signed certificate.
    endpointCA:
      # -- Creates a secret with the given value if true, otherwise uses an existing secret.
      create: false
      name: ""
      key: ""
      value: ""
    # -- Overrides the provider specific default path. Format: s3://<bucket><path>
    # Recommended naming: Use timestamp/version to enable same-name cluster recovery
    # Examples:
    #   - s3://my-backups/postgresql-temporal-2025-11-17/
    #   - s3://my-backups/temporal-cluster-2025-11/
    #   - s3://my-backups/temporal-YYYY-MM-DD/
    # When recovering, use a NEW timestamp (e.g., 2025-11-18) for post-recovery backups
    # This allows recovery to read from old path while writing new backups to a fresh timestamped path
    destinationPath: ""
    # -- Provider type (only S3-compatible storage is configured)
    provider: s3
    s3:
      region: ""
      bucket: ""
      path: "/"
      accessKey: ""
      secretKey: ""
      # -- Use the role based authentication without providing explicitly the keys
      inheritFromIAMRole: false
    secret:
      # -- Whether to create a secret for the backup credentials
      create: true
      # -- Name of the backup credentials secret
      name: ""
    wal:
      # -- WAL compression method. One of `` (for no compression), `gzip`, `bzip2` or `snappy`.
      compression: gzip
      # -- Whether to instruct the storage provider to encrypt WAL files. One of `` (use the storage container default), `AES256` or `aws:kms`.
      encryption: ""
      # -- Number of WAL files to be archived or restored in parallel.
      maxParallel: 8
    data:
      # -- Data compression method. One of `` (for no compression), `gzip`, `bzip2` or `snappy`.
      compression: gzip
      # -- Whether to instruct the storage provider to encrypt data files. One of `` (use the storage container default), `AES256` or `aws:kms`.
      encryption: ""
      # -- Number of data files to be archived or restored in parallel.
      jobs: 2
    scheduledBackups:
      - name: daily-backup
        # -- Schedule in cron format
        schedule: "0 0 0 * * *"
        # -- Backup owner reference
        backupOwnerReference: self
        # -- Backup method, can be `barmanObjectStore` (default) or `volumeSnapshot`
        method: barmanObjectStore
    # -- Retention policy for backups
    retentionPolicy: "30d"
  recovery:
    # -- For detailed configuration options, see: https://github.com/cloudnative-pg/charts/tree/main/charts/cluster
    ##
    # -- Available recovery methods:
    # * `backup` - Recovers a CNPG cluster from a CNPG backup (PITR supported) Needs to be on the same cluster in the same namespace.
    # * `object_store` - Recovers a CNPG cluster from a barman object store (PITR supported).
    # * `pg_basebackup` - Recovers a CNPG cluster viaa streaming replication protocol. Useful if you want to
    #        migrate databases to CloudNativePG, even from outside Kubernetes.
    # * `import` - Import one or more databases from an existing Postgres cluster.
    method: object_store

    ## -- Point in time recovery target. Specify one of the following:
    pitrTarget:
      # -- Time in RFC3339 format
      time: ""
    
    ## -- Recovery target settings for controlling recovery behavior
    # Options: pause, promote, shutdown
    # 'promote' is recommended - promotes to read-write immediately after recovery
    recoveryTarget: "promote"

    ##
    # -- Backup Recovery Method
    backupName: ""  # Name of the backup to recover from. Required if method is `backup`.

    ##
    # -- The original cluster name when used in backups. Also known as serverName.
    clusterName: "qs-postgresql-cluster-temporal"
    # -- Name of the database used by the application. Default: `app`.
    database: app
    # -- Name of the owner of the database in the instance to be used by applications. Defaults to the value of the `database` key.
    owner: ""
    # -- Overrides the provider specific default endpoint. Defaults to: https://s3.<region>.amazonaws.com
    # Leave empty if using the default S3 endpoint
    endpointURL: ""
    # -- Specifies a CA bundle to validate a privately signed certificate.
    endpointCA:
      # -- Creates a secret with the given value if true, otherwise uses an existing secret.
      create: false
      name: ""
      key: ""
      value: ""
    # -- Overrides the provider specific default path. Format: s3://<bucket><path>
    # IMPORTANT: For disaster recovery with same cluster name:
    #   - Set this to READ from the production backup path (e.g., s3://my-backups/temporal-2025-11-17/)
    #   - Set backups.destinationPath to WRITE to a NEW timestamped path (e.g., s3://my-backups/temporal-2025-11-18/)
    # This prevents "Expected empty archive" errors during recovery while maintaining same cluster name
    # Example recovery scenario:
    #   1. Production backups: s3://my-backups/postgresql-temporal-2025-11-17/ (original)
    #   2. Disaster occurs on 2025-11-18, cluster deleted
    #   3. Recovery reads FROM: s3://my-backups/postgresql-temporal-2025-11-17/ (this field)
    #   4. New backups write TO: s3://my-backups/postgresql-temporal-2025-11-18/ (backups.destinationPath)
    # Benefits: Clear timeline, allows multiple recoveries, consistent naming pattern
    destinationPath: ""
    # -- Provider type (only S3-compatible storage is configured)
    provider: s3
    s3:
      region: ""
      bucket: ""
      path: "/"
      accessKey: ""
      secretKey: ""
      # -- Use the role based authentication without providing explicitly the keys
      inheritFromIAMRole: false
    secret:
      # -- Whether to create a secret for the backup credentials
      create: true
      # -- Name of the backup credentials secret
      name: ""


  # -- Configuration for role-to-pooler mappings
  config:
    # Default pooler for roles without specific mapping
    # If empty or not set, unmapped roles use direct cluster connection
    # If set, unmapped roles will use this pooler
    defaultPooler: "session"  # All temporal roles use session pooler by default

    # Role-specific pooler mappings (overrides defaultPooler)
    # Maps each role to a specific pooler (optional)
    rolePoolerMappings:
      # temporal: session  # Not needed - uses defaultPooler
      # temporal_visibility: session  # Not needed - uses defaultPooler
      # Add role-specific overrides here if needed
  # -- List of PgBouncer poolers
  poolers:
    # Session mode pooler - for databases that require session state
    # Recommended for: Temporal workflow databases requiring session state
    - name: session
      # -- PgBouncer type of service to forward traffic to.
      type: rw
      # -- PgBouncer pooling mode
      poolMode: session
      # -- Number of PgBouncer instances
      instances: 3
      # -- PgBouncer configuration parameters
      parameters:
        max_client_conn: "600"
        default_pool_size: "80"
        reserve_pool_size: "10"
        server_lifetime: "3600"
        server_idle_timeout: "600"
        server_tls_sslmode: require
        ignore_startup_parameters: extra_float_digits
        auth_type: scram-sha-256
        log_connections: "0"
        log_disconnections: "0"
        log_pooler_errors: "1"
        log_stats: "1"
