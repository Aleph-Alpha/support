apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "qs-minio.fullname" . }}-secret-script
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "qs-minio.labels" . | nindent 4 }}
    app.kubernetes.io/component: secret-script
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-10"
    "helm.sh/hook-delete-policy": before-hook-creation
data:
  create-secrets.sh: |
    #!/bin/bash

    # Set error handling
    [[ "${FAIL_ON_ERROR}" == "true" ]] && set -e

    # Log level configuration
    get_log_level_value() {
        case "${1}" in
            debug) echo 0 ;;
            info) echo 1 ;;
            warning) echo 2 ;;
            error) echo 3 ;;
            *) echo 1 ;;
        esac
    }
    CURRENT_LOG_LEVEL=$(get_log_level_value "${LOG_LEVEL:-info}")

    # Colors for output
    if [[ "${COLORED_OUTPUT}" == "true" ]]; then
        RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'
        BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'
    else
        RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; NC=''
    fi

    # Logging functions
    should_log() {
        local level_value=$(get_log_level_value "$1")
        [[ $level_value -ge $CURRENT_LOG_LEVEL ]]
    }

    print_debug() { should_log "debug" && echo -e "${CYAN}[DEBUG]${NC} $1"; return 0; }
    print_status() { should_log "info" && echo -e "${BLUE}[INFO]${NC} $1"; return 0; }
    print_success() { should_log "info" && echo -e "${GREEN}[SUCCESS]${NC} $1"; return 0; }
    print_warning() { should_log "warning" && echo -e "${YELLOW}[WARNING]${NC} $1"; return 0; }
    print_error() { should_log "error" && echo -e "${RED}[ERROR]${NC} $1"; return 0; }
    print_dry_run() { echo -e "${CYAN}[DRY-RUN]${NC} $1"; return 0; }

    # Generate random password
    generate_password() {
        openssl rand -base64 32 | tr -d "=+/" | cut -c1-25
    }

    # Statistics tracking
    secrets_created=0
    secrets_updated=0
    secrets_skipped=0
    secrets_failed=0

    # Check if secret needs updating
    check_secret_changes() {
        local secret_name=$1
        local endpoint_url=$2
        local username=$3
        local user_key=$4

        local existing_endpoint=$(kubectl get secret "$secret_name" -o jsonpath='{.data.endpointUrl}' 2>/dev/null | base64 -d)
        local existing_username=$(kubectl get secret "$secret_name" -o jsonpath="{.data.$user_key}" 2>/dev/null | base64 -d)
        local existing_minio_label=$(kubectl get secret "$secret_name" -o jsonpath='{.metadata.labels.qs-minio/instance}' 2>/dev/null)

        local needs_update=false

        if [[ "$existing_endpoint" != "$endpoint_url" ]]; then print_warning "Endpoint URL changed: '$existing_endpoint' -> '$endpoint_url'" >&2; needs_update=true; fi
        if [[ "$existing_username" != "$username" ]]; then print_warning "Username changed or missing: '$existing_username' -> '$username'" >&2; needs_update=true; fi
        if [[ "$existing_minio_label" != "${INSTANCE_NAME}" ]]; then print_warning "Instance label changed" >&2; needs_update=true; fi

        echo "$needs_update"
    }

    # Create or update a secret
    create_or_update_secret() {
        local secret_name=$1
        local username=$2
        local password=$3
        local host=$4
        local user_key=$5
        local password_key=$6
        local action=$7
        local bucket=$8  # Optional bucket parameter

        local base_args="--from-literal=$user_key=$username --from-literal=$password_key=$password --from-literal=endpointUrl=$host"

        # Add bucket if specified
        if [[ -n "$bucket" ]]; then
            base_args="$base_args --from-literal=bucket=$bucket"
        fi

        if kubectl create secret generic "$secret_name" $base_args --dry-run=client -o yaml | \
           kubectl label --local -f - app.kubernetes.io/name="${APP_NAME}" qs-minio/instance="${INSTANCE_NAME}" -o yaml | \
           kubectl apply -f - > /dev/null 2>&1; then
            if [[ -n "$bucket" ]]; then
                print_success "Secret '$secret_name' ready (user: $username, endpoint: $host, bucket: $bucket)"
            else
                print_success "Secret '$secret_name' ready (user: $username, endpoint: $host)"
            fi
            [[ "$action" == "create" ]] && secrets_created=$((secrets_created + 1)) || secrets_updated=$((secrets_updated + 1))
            return 0
        else
            print_error "Failed to ${action} secret '$secret_name'"
            secrets_failed=$((secrets_failed + 1))
            if [[ "${FAIL_ON_ERROR}" == "true" ]]; then
                exit 1
            fi
            return 1
        fi
    }

    # Parse bucket name from bucket specification (removes policy suffix)
    # Format can be: "bucket-name" or "bucket-name:policy"
    parse_bucket_name() {
        local bucket_spec=$1
        echo "${bucket_spec%%:*}"
    }

    # Create per-bucket secrets
    create_bucket_secrets() {
        local password=$1
        local minio_url=$2

        if [[ -z "${DEFAULT_BUCKETS}" ]]; then
            print_debug "No default buckets configured, skipping bucket-specific secrets"
            return 0
        fi

        print_status "Creating bucket-specific secrets..."

        # Parse buckets - they can be comma, semicolon, or space separated
        local buckets="${DEFAULT_BUCKETS}"
        buckets="${buckets//,/ }"
        buckets="${buckets//;/ }"

        for bucket_spec in $buckets; do
            if [[ -z "$bucket_spec" ]]; then
                continue
            fi

            # Extract bucket name (strip policy if present)
            local bucket_name=$(parse_bucket_name "$bucket_spec")
            local bucket_secret_name="${EXISTING_SECRET_NAME}-${bucket_name}"

            print_debug "Processing bucket: $bucket_name (from spec: $bucket_spec)"

            # Check if bucket secret exists
            if [[ "${DRY_RUN}" != "true" ]] && kubectl get secret "$bucket_secret_name" &> /dev/null; then
                print_status "Bucket secret '$bucket_secret_name' exists, checking for changes..."

                local existing_password=$(kubectl get secret "$bucket_secret_name" -o jsonpath="{.data.$PASSWORD_KEY}" 2>/dev/null | base64 -d)
                local needs_update=$(check_secret_changes "$bucket_secret_name" "$minio_url" "$MINIO_USER" "$USER_KEY")

                if [[ "$needs_update" == "true" ]]; then
                    print_status "Updating bucket secret with preserved password"
                    create_or_update_secret "$bucket_secret_name" "$MINIO_USER" "$existing_password" "$minio_url" "$USER_KEY" "$PASSWORD_KEY" "update" "$bucket_name"
                else
                    print_success "Bucket secret '$bucket_secret_name' is up to date, skipping"
                    secrets_skipped=$((secrets_skipped + 1))
                fi
            else
                # Create new bucket secret
                if [[ "${DRY_RUN}" == "true" ]]; then
                    print_dry_run "Would create bucket secret: $bucket_secret_name (bucket: $bucket_name)"
                    secrets_created=$((secrets_created + 1))
                else
                    print_status "Creating new bucket secret: $bucket_secret_name"
                    create_or_update_secret "$bucket_secret_name" "$MINIO_USER" "$password" "$minio_url" "$USER_KEY" "$PASSWORD_KEY" "create" "$bucket_name"
                fi
            fi
        done
    }

    # Process MinIO secret
    create_minio_secret() {
        if [[ "${DRY_RUN}" == "true" ]]; then
            print_dry_run "DRY-RUN MODE: No actual changes will be made"
            echo ""
        fi

        # Construct full MinIO URL with protocol and port
        local minio_url="${MINIO_PROTOCOL}://${MINIO_HOST}:${MINIO_PORT}"

        print_status "Processing MinIO secret for instance: ${INSTANCE_NAME}..."
        print_debug "MinIO fullname: ${MINIO_FULLNAME}"
        print_debug "MinIO URL: ${minio_url}"
        print_debug "Secret name: ${EXISTING_SECRET_NAME}"
        print_debug "User key: ${USER_KEY}"
        print_debug "Password key: ${PASSWORD_KEY}"
        print_debug "Default buckets: ${DEFAULT_BUCKETS:-<none>}"

        local password=""

        # Check if secret exists
        if [[ "${DRY_RUN}" != "true" ]] && kubectl get secret "$EXISTING_SECRET_NAME" &> /dev/null; then
            print_status "Secret '$EXISTING_SECRET_NAME' exists, checking for changes..."

            local existing_password=$(kubectl get secret "$EXISTING_SECRET_NAME" -o jsonpath="{.data.$PASSWORD_KEY}" 2>/dev/null | base64 -d)
            password="$existing_password"
            local needs_update=$(check_secret_changes "$EXISTING_SECRET_NAME" "$minio_url" "$MINIO_USER" "$USER_KEY")

            print_debug "  Needs update: $needs_update"

            if [[ "$needs_update" == "true" ]]; then
                print_status "Updating secret with preserved password"
                create_or_update_secret "$EXISTING_SECRET_NAME" "$MINIO_USER" "$existing_password" "$minio_url" "$USER_KEY" "$PASSWORD_KEY" "update"
            else
                print_success "Secret '$EXISTING_SECRET_NAME' is up to date, skipping"
                secrets_skipped=$((secrets_skipped + 1))
            fi
        else
            # Create new secret
            if [[ "${DRY_RUN}" == "true" ]]; then
                print_dry_run "Would create secret: $EXISTING_SECRET_NAME (user: $MINIO_USER, host: $minio_url)"
                secrets_created=$((secrets_created + 1))
                password=$(generate_password)
            else
                print_status "Creating new secret: $EXISTING_SECRET_NAME"
                password=$(generate_password)
                create_or_update_secret "$EXISTING_SECRET_NAME" "$MINIO_USER" "$password" "$minio_url" "$USER_KEY" "$PASSWORD_KEY" "create"
            fi
        fi

        # Create bucket-specific secrets if buckets are configured
        if [[ -n "${DEFAULT_BUCKETS}" ]]; then
            echo ""
            create_bucket_secrets "$password" "$minio_url"
        fi

        # Print summary
        echo ""
        print_status "Summary for MinIO instance '${INSTANCE_NAME}':"
        print_status "  - Created: ${secrets_created}"
        print_status "  - Updated: ${secrets_updated}"
        print_status "  - Skipped: ${secrets_skipped}"
        if [[ $secrets_failed -gt 0 ]]; then
            print_warning "  - Failed: ${secrets_failed}"
        fi
    }

    # Main execution
    main() {
        print_status "MinIO Secret Management Job"
        print_status "============================"
        echo ""

        # Validate environment variables
        for var in INSTANCE_NAME MINIO_HOST MINIO_USER EXISTING_SECRET_NAME USER_KEY PASSWORD_KEY APP_NAME; do
            if [[ -z "${!var}" ]]; then
                print_error "$var environment variable is required"
                exit 1
            fi
        done

        # Show configuration
        print_status "Configuration:"
        print_status "  - Instance: ${INSTANCE_NAME}"
        print_status "  - Log Level: ${LOG_LEVEL:-info}"
        print_status "  - Dry Run: ${DRY_RUN:-false}"
        print_status "  - Fail On Error: ${FAIL_ON_ERROR:-true}"
        print_debug "  - MinIO Host: ${MINIO_HOST}"
        print_debug "  - MinIO User: ${MINIO_USER}"
        print_debug "  - Secret Name: ${EXISTING_SECRET_NAME}"
        echo ""

        # Check required commands
        print_status "Checking required commands..."
        if ! command -v kubectl &> /dev/null; then
            print_error "kubectl not found in PATH"
            exit 1
        fi
        if [[ "${DRY_RUN}" != "true" ]] && ! command -v openssl &> /dev/null; then
            print_error "openssl not found (needed for password generation)"
            exit 1
        fi
        print_debug "kubectl: $(command -v kubectl)"
        if [[ "${DRY_RUN}" != "true" ]]; then
            print_debug "openssl: $(command -v openssl)"
        fi
        echo ""

        # Create secret
        create_minio_secret
        echo ""

        # Final status
        if [[ "${DRY_RUN}" == "true" ]]; then
            print_success "Dry-run completed for MinIO instance '${INSTANCE_NAME}'!"
        else
            print_success "Secret processing completed for MinIO instance '${INSTANCE_NAME}'!"
        fi

        # Exit with error if any secrets failed
        if [[ $secrets_failed -gt 0 ]] && [[ "${FAIL_ON_ERROR}" == "true" ]]; then
            print_error "Job completed with ${secrets_failed} failure(s)"
            exit 1
        fi
    }

    # Run main function
    main "$@"
